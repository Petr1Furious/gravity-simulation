#pragma comment(linker, "/SUBSYSTEM:windows /ENTRY:mainCRTStartup")
#define _USE_MATH_DEFINES
#include<SFML/Graphics.hpp>
#include<unordered_map>
#include<Windows.h>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<sstream>
#include<atomic>
#include<thread>
#include<random>
#include<chrono>
#include<deque>
#include<cmath>
#include<mutex>
#include<queue>
#include<map>
#include<set>
typedef long double ld;
template <typename T>
std::string to_string(const T x, const int n = 6) {
	std::ostringstream out;
	out.precision(n);
	out << std::fixed << x;
	return out.str();
}
std::string to_string(const ld x) {
	std::ostringstream out;
	out << x;
	return out.str();
}
using namespace sf;
Clock timer__;
ld gettime() {
	return (ld)timer__.getElapsedTime().asMicroseconds() / (ld)1e6;
}
ld dist2(ld x1, ld y1, ld x2, ld y2) {
	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}
ld dist(ld x1, ld y1, ld x2, ld y2) {
	return sqrt(dist2(x1, y1, x2, y2));
}
ld getdrawx(ld x, ld cx, ld scale, ld wx) {
	return (x - cx) / scale + wx / 2;
}
ld getdrawy(ld y, ld cy, ld scale, ld wy) {
	return (-y + cy) / scale + wy / 2;
}
ld getrealx(ld x, ld cx, ld scale, ld wx) {
	return (x - wx / 2) * scale + cx;
}
ld getrealy(ld y, ld cy, ld scale, ld wy) {
	return -((y - wy / 2) * scale - cy);
}
//std::mt19937_64 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
std::mt19937_64 rnd(0);
long long randnum(long long l, long long r) {
	return rnd() % (r - l + 1) + l;
}
template<class T>
float getWidth(const T& t) {
	auto temp = t.getGlobalBounds();
	return temp.width;
}
template<class T>
float getHeight(const T& t) {
	auto temp = t.getGlobalBounds();
	return temp.height;
}
std::string formatTime(ld time) {
	std::vector<std::pair<ld, std::string>> t = { {1e-9, "ns"}, {1e-6, "µs"}, {1e-3, "ms"}, {1, "s"}, {60, "m"}, {3600, "h"}, {86400, "d"}, {31558149.984, "y"}, {31558149.984e3, "Ky"}, {31558149.984e6, "My"}, {31558149.984e9, "Gy"}, {31558149.984e12, "Ty"} };
	int j = std::max(0, (int)(std::upper_bound(t.begin(), t.end(), std::make_pair(time + (ld)1e-5, std::string(0, ' '))) - t.begin()) - 1);
	return to_string(time / t[j].first, 3) + " " + t[j].second;
}
std::string formatDist(ld dist) {
	std::vector<std::pair<ld, std::string>> t = { {1e-9, "nm"}, {1e-6, "µm"}, {1e-3, "mm"}, {1, "m"}, {1e3, "km"}, {1e6, "Mm"}, {1e9, "Gm"}, {1e12, "Tm"}, {25902068371240.l, "ld"}, {9460730472580800.l, "ly"} };
	int j = std::max(0, (int)(std::upper_bound(t.begin(), t.end(), std::make_pair(dist + (ld)1e-5, std::string(0, ' '))) - t.begin()) - 1);
	return to_string(dist / t[j].first, 3) + " " + t[j].second;
}
ld getVolume(const ld& r) {
	return (ld)4 / 3 * M_PI * r * r * r;
}
std::string getName(std::vector<std::string>lines) {
	int mx = 0;
	for (auto s : lines)mx = std::max(mx, (int)s.size());
	std::string res;
	for (auto s : lines) {
		res += std::string((mx - (int)s.size()), ' ') + s + "\n";
	}
	return res;
}
void drawLineSegment(RenderWindow* window, ld x1, ld y1, ld x2, ld y2, const Color& color) {
	Vertex vertices[2];
	vertices[0] = Vertex(Vector2f(x1, y1), color);
	vertices[1] = Vertex(Vector2f(x2, y2), color);
	window->draw(vertices, 2, Lines);
}
void drawArrow(RenderWindow* window, ld x1, ld y1, ld x2, ld y2, Color color) {
	drawLineSegment(window, x1, y1, x2, y2, color);
	ld d = dist(x1, y1, x2, y2);
	if (d > 4) {
		CircleShape temp(4, 3);
		temp.setOrigin(4, 4);
		temp.setRotation(std::atan2(y2 - y1, x2 - x1) / M_PI * 180 + 90);
		temp.setPosition(x2, y2);
		temp.setFillColor(color);
		window->draw(temp);
	}
}
int curIdCounter = 0;
struct planet {
	static constexpr ld G = (ld)6.67408e-11;
	static constexpr ld DENSITY = 5510;
	ld x, y;
	ld vx, vy;
	ld r, m;
	int id;
	bool selected;
	std::string name;
	std::vector<std::pair<ld, ld>> trace;
	planet() {
		id = curIdCounter++;
	}
	planet(ld _x, ld _y, ld _vx, ld _vy, ld _r, ld _m, std::string _name = std::string(), bool _selected = false, std::vector<std::pair<ld, ld>> trace = std::vector<std::pair<ld, ld>>()) : 
		x(_x), y(_y), vx(_vx), vy(_vy), r(_r), m(_m), selected(_selected), name(_name), trace(trace) {
		id = curIdCounter++;
	}
	void updateCoords(ld dt) {
		x += vx * dt;
		y += vy * dt;
	}
	void updateVelocity(ld dt, const std::vector<planet>& p) {
		ld ax = 0, ay = 0;
		for (const auto& s : p) {
			if (s == (*this))continue;
			ld d2 = dist2(x, y, s.x, s.y);
			ld d3 = d2 * sqrt(d2);
			ax += s.m * (s.x - x) / d3;
			ay += s.m * (s.y - y) / d3;
		}
		ax *= planet::G;
		ay *= planet::G;
		vx += ax * dt;
		vy += ay * dt;
	}
	void continueTrace(int maxSz) {
		if (trace.empty() || dist(x, y, trace.back().first, trace.back().second) > r) {
			trace.push_back(std::make_pair(x, y));
		}
		if (maxSz >= 0 && trace.size() > maxSz) {
			int toErase = (int)trace.size() - (int)(maxSz * 0.9);
			trace.erase(trace.begin(), trace.begin() + toErase);
		}
	}
	void clearTrace() {
		trace.clear();
	}
	void drawTrace(RenderWindow* window, ld cx, ld cy, ld scale) {
		for (int i = 0; i < (int)trace.size() - 1; i++) {
			ld x1 = trace[i].first, y1 = trace[i].second, x2 = trace[i + 1].first, y2 = trace[i + 1].second;
			drawLineSegment(window, getdrawx(x1, cx, scale, window->getSize().x), getdrawy(y1, cy, scale, window->getSize().y),
				getdrawx(x2, cx, scale, window->getSize().x), getdrawy(y2, cy, scale, window->getSize().y), Color::Blue);
		}
	}
	void draw(RenderWindow* window, ld cx, ld cy, ld scale) {
		int drawR = std::max(1, (int)(r / scale));
		CircleShape c(drawR);
		c.setFillColor(Color(172, 174, 216));
		c.setOrigin(drawR, drawR);
		c.setPosition(getdrawx(x, cx, scale, window->getSize().x), getdrawy(y, cy, scale, window->getSize().y));
		window->draw(c);
	}
	bool operator==(const planet& s)const {
		return x == s.x && y == s.y && vx == s.vx && vy == s.vy && r == s.r && m == s.m;
	}
};
bool collide(const planet& p1, const planet& p2) {
	return (dist(p1.x, p1.y, p2.x, p2.y) <= (p1.r + p2.r));
}
planet operator+(const planet& p1, const planet& p2) {
	if (p1.m == 0 && p2.m == 0) {
		return planet(p1.x, p1.y, (p1.vx + p2.vx) / 2, (p1.vy + p2.vy) / 2, pow(p1.r * p1.r * p1.r + p2.r * p2.r * p2.r, 1.f / 3.f), 0);
	}
	ld px = p1.vx * p1.m + p2.vx * p2.m;
	ld py = p1.vy * p1.m + p2.vy * p2.m;
	ld m = p1.m + p2.m;
	ld x = (p1.x * p1.m + p2.x * p2.m) / m;
	ld y = (p1.y * p1.m + p2.y * p2.m) / m;
	std::string name;
	std::vector<std::pair<ld, ld>> trace;
	if (p1.m > p2.m) {
		name = p1.name;
		trace = p1.trace;
	}
	else {
		name = p2.name;
		trace = p2.trace;
	}
	return planet(x, y, px / m, py / m, pow(p1.r * p1.r * p1.r + p2.r * p2.r * p2.r, 1.f / 3.f), m, name, p1.selected || p2.selected, trace);
}
struct psystem {
private:
	std::vector<std::pair<int, int>> recentlyCollided;
	std::pair<int, int> findCollision1() {
		std::vector<std::pair<ld, int>> v;
		for (int i = 0; i < s.size(); i++) {
			v.push_back({ s[i].x - s[i].r, -i - 1 });
			v.push_back({ s[i].x + s[i].r, i });
		}
		std::sort(v.begin(), v.end());
		std::set<std::pair<ld, int>> setik;
		for (auto i : v) {
			int id = ((i.second >= 0) ? i.second : (-i.second - 1));
			if (i.second < 0) {
				auto it = setik.lower_bound(std::make_pair(s[id].y, -1));
				if (it != setik.end() && collide(s[it->second], s[id])) {
					return std::make_pair(it->second, id);
				}
				if (it != setik.begin())it--;
				if (it != setik.end() && collide(s[it->second], s[id])) {
					return std::make_pair(it->second, id);
				}
				setik.insert(std::make_pair(s[id].y, id));
			}
			else {
				setik.erase(std::make_pair(s[id].y, id));
				auto it = setik.lower_bound(std::make_pair(s[id].y, -1));
				if (it != setik.end() && collide(s[it->second], s[id])) {
					return std::make_pair(it->second, id);
				}
				if (it != setik.begin())it--;
				if (it != setik.end() && collide(s[it->second], s[id])) {
					return std::make_pair(it->second, id);
				}
			}
		}
		return std::make_pair(-1, -1);
	}
	std::pair<int, int> findCollision2() {
		std::vector<int> heavy;
		for (int i = 0; i < s.size(); i++) {
			if (s[i].m != 0) {
				heavy.push_back(i);
			}
		}
		for (int i = 0; i < s.size(); i++) {
			for (auto j : heavy) {
				if (i != j && collide(s[i], s[j])) {
					return std::make_pair(i, j);
				}
			}
		}
		return std::make_pair(-1, -1);
	}
public:
	std::vector<planet> s;
	psystem() : s(std::vector<planet>()) {}
	psystem(std::vector<planet>s) : s(s) {}
	void clear() {
		s.clear();
	}
	void deletePlanet(int i) {
		s.erase(s.begin() + i);
	}
	void insertPlanet(const planet& p) {
		s.push_back(p);
	}
	void updateCoords(ld dt) {
		for (auto& p : s) {
			p.updateCoords(dt);
		}
	}
	void updateVelocity(ld dt) {
		std::vector<planet> heavy;
		for (const auto& p : s) {
			if (p.m != 0)heavy.push_back(p);
		}
		for (auto& p : s) {
			p.updateVelocity(dt, heavy);
		}
	}
	void updateCollided() {
		int n = 0, m = 0;
		for (auto i : s) {
			if (i.m != 0) {
				n++;
			}
			else {
				m++;
			}
		}
		while (true) {
			std::pair<int, int> temp;
			if (log2(n + m) <= n) {
				temp = findCollision1();
			}
			else {
				temp = findCollision2();
			}
			if (s[temp.first].m > s[temp.second].m) {
				recentlyCollided.push_back(std::make_pair(s[temp.first].id, s[temp.second].id));
			}
			else {
				recentlyCollided.push_back(std::make_pair(s[temp.second].id, s[temp.first].id));
			}
			if (temp.first == -1) break;
			if (temp.first < temp.second) std::swap(temp.first, temp.second);
			s.push_back(s[temp.first] + s[temp.second]);
			deletePlanet(temp.first);
			deletePlanet(temp.second);
		}
	}
	std::vector<std::pair<int, int>> getRecentlyCollided() {
		std::vector<std::pair<int, int>> res;
		std::swap(res, recentlyCollided);
		return res;
	}
	std::vector<planet> getPlanets()const {
		return s;
	}
};
struct DSU {
	std::vector<int> p;
	void clear() {
		p.clear();
		p.shrink_to_fit();
	}
	void resize(int n) {
		n++;
		if (p.size() < n) {
			int from = n;
			p.resize(n);
			for (int i = from; i < n; i++) {
				p[i] = i;
			}
		}
	}
	int get(int v) {
		resize(v);
		return p[v] == v ? v : p[v] = get(p[v]);
	}
	void unite(int v, int u) {
		resize(v);
		resize(u);
		p[get(v)] = get(u);
	}
	void update(std::vector<std::pair<int, int>> v) {
		for (auto i : v) {
			unite(i.first, i.second);
		}
	}
};
struct gamestate {
private:
	psystem s;
	bool opened;
	std::mutex mtx;
	std::queue<ld> updateTimes;
	std::mutex mtx2;
	std::vector<planet> toChange;
	std::vector<int> toDelete;
	int toSelect;
public:
	ld timeSpeed;
	bool realtime;
	bool paused;
	bool fullScreenMode;
	DSU d;
	gamestate() : s(), timeSpeed(1), toSelect(-1), opened(true), realtime(true), paused(false), fullScreenMode(false) {}
	void clear() {
		toChange.clear();
		toDelete.clear();
		while (!updateTimes.empty())updateTimes.pop();
	}
	void addUpdateTime() {
		updateTimes.push(gettime());
		while (updateTimes.back() - updateTimes.front() >= 1)updateTimes.pop();
	}
	ld getUpdatesPerSecond()const {
		if (updateTimes.size() <= 1) {
			return 0;
		}
		return ((ld)updateTimes.size() - 1) / (updateTimes.back() - updateTimes.front());
	}
	bool isOpen()const {
		return opened;
	}
	void close() {
		opened = false;
	}
	void open() {
		opened = true;
	}
	void lock() {
		mtx.lock();
	}
	void unlock() {
		mtx.unlock();
	}
	psystem getPlanets()const {
		return s;
	}
	void setPlanets(const psystem& newS) {
		mtx2.lock();
		std::set<int> deleteId;
		for (auto i : s.getPlanets()) deleteId.insert(i.id);
		for (auto i : newS.getPlanets()) {
			deleteId.erase(i.id);
			toChange.push_back(i);
		}
		for (auto i : deleteId) toDelete.push_back(i);
		mtx2.unlock();
	}
	void setPlanetsLocked(const psystem& newS) {
		s = newS;
	}
	void insertPlanet(const planet& p) {
		mtx2.lock();
		toChange.push_back(p);
		mtx2.unlock();
	}
	void deletePlanet(int id) {
		mtx2.lock();
		toDelete.push_back(id);
		mtx2.unlock();
	}
	void select(int id) {
		toSelect = id;
	}
	void updateActions() {
		mtx2.lock();
		std::set<int> del, noAdd;
		for (auto i : toChange) del.insert(i.id);
		for (auto i : toDelete) del.insert(i), noAdd.insert(i);
		int it = (int)s.s.size() - 1;
		for (int i = (int)s.s.size() - 1; i >= 0; i--) {
			if (del.find(s.s[i].id) != del.end()) {
				std::swap(s.s[i], s.s[it--]);
			}
		}
		while ((int)s.s.size() - 1 > it) {
			s.s.pop_back();
		}
		for (auto i : toChange) if (noAdd.find(i.id) == noAdd.end()) s.insertPlanet(i);
		toChange.clear();
		toDelete.clear();
		if (toSelect != -2) {
			for (int i = 0; i < s.s.size(); i++) {
				if (s.s[i].id == toSelect) {
					s.s[i].selected = true;
				}
				else if (s.s[i].selected) {
					s.s[i].selected = false;
				}
			}
			toSelect = -2;
		}
		mtx2.unlock();
	}
	void deletePlanets(ld x, ld y, ld maxdist) {
		for (const auto& i : s.s) {
			if (dist(x, y, i.x, i.y) <= maxdist + i.r) {
				deletePlanet(i.id);
			}
		}
	}
};
struct Params {
	RenderWindow* window;
	gamestate* p;
};
void calculations(Params* params) {
	RenderWindow* window = params->window;
	gamestate* p = params->p;
	ld lastUpdated = gettime();
	p->lock();
	psystem last = p->getPlanets();
	p->unlock();
	while (p->isOpen()) {
		ld dt = gettime() - lastUpdated;
		lastUpdated = gettime();
		p->lock();
		last = p->getPlanets();
		p->unlock();
		ld curtime;
		if (p->realtime) {
			curtime = dt * p->timeSpeed;
		}
		else {
			curtime = p->timeSpeed / (ld)500;
		}
		if (!p->paused) {
			last.updateVelocity(curtime);
			last.updateCoords(curtime);
			last.updateCollided();
		}
		p->lock();
		p->setPlanetsLocked(last);
		p->updateActions();
		p->addUpdateTime();
		p->unlock();
		Sleep(1);
	}
}
struct Chat {
	static constexpr int BORDER = 4;
	static constexpr int FONT_SIZE = 20;
	std::vector<std::pair<ld, String>>messages;
	std::vector<String>sent;
	String curMessage, oldMessage;
	bool typingNickname;
	String curAutoPart;
	String curAuto;
	bool typing;
	int selectedMessagePos;
	int posStartDrawing;
	int messagePos;
	ld lastCursorMoved;

	Chat() : typing(false), typingNickname(false) {}
	bool wordPart(Uint32 c) {
		return '0' <= c && c <= '9' || 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || c == '_' || 1040 <= c && c <= 1103 || c == 1105 || c == 1025;
	}
	Uint32 lower(Uint32 c) {
		if ('A' <= c && c <= 'Z') {
			return c - 'A' + 'a';
		}
		return c;
	}
	String getCurrentWord() {
		String res;
		for (int i = messagePos - 1; i >= -1; i--) {
			if (i == -1 || !wordPart(curMessage[i]) && curMessage[i] != '/')break;
			res += curMessage[i];
		}
		std::reverse(res.begin(), res.end());
		return res;
	}
	void putChar(Uint32 c, std::vector<String>nicknames = std::vector<String>()) {
		lastCursorMoved = gettime();
		if (c == 13) {}
		else if (c == 8) {
			typingNickname = false;
			if (messagePos > 0) {
				curMessage.erase(messagePos-- - 1);
			}
		}
		else if (c == 127) {
			typingNickname = false;
			bool everWordPart = false;
			for (int i = messagePos - 1; i >= -1; i--) {
				if (i == -1 || everWordPart && !wordPart(curMessage[i])) {
					curMessage.erase(i + 1, messagePos - (i + 1) + 1);
					messagePos = i + 1;
					break;
				}
				if (wordPart(curMessage[i]))everWordPart = true;
			}
		}
		else if (c == 9) {
			if (!typingNickname) {
				typingNickname = true;
				curAutoPart.clear();
				curAuto.clear();
				curAutoPart = getCurrentWord();
			}
			std::sort(nicknames.begin(), nicknames.end());
			std::vector<String>prefixOf;
			for (auto s : nicknames) {
				if (curAutoPart.getSize() > s.getSize())continue;
				bool isPrefix = true;
				for (int i = 0; i < curAutoPart.getSize(); i++) {
					if (lower(s[i]) != lower(curAutoPart[i])) {
						isPrefix = false;
						break;
					}
				}
				if (isPrefix && !(curAutoPart.getSize() == 0 && !s.isEmpty() && s[0] == '/')) {
					prefixOf.push_back(s);
				}
			}
			if (!prefixOf.empty()) {
				bool found = false;
				for (int i = 0; i < prefixOf.size(); i++) {
					if (curAuto == prefixOf[i]) {
						curAuto = prefixOf[(i + 1) % (int)prefixOf.size()];
						found = true;
						break;
					}
				}
				if (!found)curAuto = prefixOf[0];
				for (int i = messagePos - 1; i >= -1; i--) {
					if (i == -1 || !wordPart(curMessage[i]) && curMessage[i] != '/') {
						curMessage.erase(i + 1, messagePos - i - 1);
						curMessage.insert(i + 1, curAuto);
						messagePos = i + 1 + curAuto.getSize();
						break;
					}
				}
			}
		}
		else {
			typingNickname = false;
			if (curMessage.getSize() < 150) {
				curMessage.insert(messagePos, c);
				messagePos++;
			}
		}
	}
	void deleteSymbol() {
		typingNickname = false;
		if (messagePos < curMessage.getSize()) {
			curMessage.erase(messagePos);
			lastCursorMoved = gettime();
		}
	}
	void putMessage(String message) {
		messages.push_back(std::make_pair(gettime(), message));
		if (posStartDrawing == (int)messages.size() - 21)posStartDrawing++;
	}
	void send() {
		sent.push_back(curMessage);
	}
	void setTyping(bool flag) {
		typing = flag;
		if (!typing) {
			curMessage.clear();
		}
		else {
			typingNickname = false;
			selectedMessagePos = sent.size();
			posStartDrawing = std::max(0, (int)messages.size() - 20);
			messagePos = 0;
			lastCursorMoved = gettime();
		}
	}
	bool getTyping() {
		return typing;
	}
	String getMessage() {
		String returnMessage = curMessage;
		return returnMessage;
	}
	void goUp() {
		typingNickname = false;
		int oldPos = selectedMessagePos;
		if (selectedMessagePos == sent.size())oldMessage = curMessage;
		selectedMessagePos = std::max(0, selectedMessagePos - 1);
		if (selectedMessagePos != sent.size())curMessage = sent[selectedMessagePos];
		else curMessage = oldMessage;
		if (oldPos != selectedMessagePos)messagePos = curMessage.getSize();
		lastCursorMoved = gettime();
	}
	void goDown() {
		typingNickname = false;
		int oldPos = selectedMessagePos;
		selectedMessagePos = std::min((int)sent.size(), selectedMessagePos + 1);
		if (selectedMessagePos != sent.size())curMessage = sent[selectedMessagePos];
		else curMessage = oldMessage;
		if (oldPos != selectedMessagePos)messagePos = curMessage.getSize();
		lastCursorMoved = gettime();
	}
	void scroll(int steps) {
		posStartDrawing = std::min(std::max(0, posStartDrawing - steps), std::max(0, (int)messages.size() - 20));
	}
	void moveCursor(int steps) {
		typingNickname = false;
		messagePos = std::max(0, std::min((int)curMessage.getSize(), messagePos + steps));
		lastCursorMoved = gettime();
	}
	void moveCursorCtrl(int direction) {
		typingNickname = false;
		while (true) {
			moveCursor(direction);
			if (messagePos == 0 || messagePos == curMessage.getSize())break;
			if (!wordPart(curMessage[messagePos - 1]) && wordPart(curMessage[messagePos]))break;
		}
	}
	void draw(RenderWindow* window, const Font& font) {
		int start = (!typing ? (std::max(0, (int)messages.size() - 3)) : posStartDrawing);
		int cnt = (!typing ? cnt = std::min((int)messages.size(), 3) : std::min((int)messages.size() - posStartDrawing, 20));
		for (int i = start; i < start + cnt; i++) {
			int alpha = 191;
			ld dt = gettime() - messages[i].first;
			if (dt >= 6 && !typing) {
				alpha -= 191 * (dt - 6);
			}
			if (alpha <= 0)continue;
			Text temp(messages[i].second, font, 20);
			temp.setPosition(20, window->getSize().y - 1 - (start + cnt - i + 1) * 30);
			temp.setFillColor(Color(255, 255, 255, alpha));
			window->draw(temp);
		}
		if (typing) {
			Text temp(curMessage, font, FONT_SIZE);
			temp.setPosition(20, window->getSize().y - 1 - 30);
			temp.setFillColor(Color(255, 255, 255, 191));
			if ((int)((gettime() - lastCursorMoved) * 10) % 10 < 5) {
				Text part(curMessage.substring(0, messagePos), font, FONT_SIZE);
				part.setPosition(20, window->getSize().y - 1 - 30);
				auto frect = part.getGlobalBounds();
				RectangleShape tempRect;
				tempRect.setPosition(frect.left + frect.width, window->getSize().y - 1 - 26);
				tempRect.setSize(Vector2f(3, 20));
				tempRect.setFillColor(Color(255, 255, 255, 191));
				window->draw(tempRect);
			}
			window->draw(temp);
		}
	}
};
std::vector<String>parseCommand(String command) {
	command += ' ';
	std::vector<String>res;
	int pos = 0;
	for (int i = 0; i < command.getSize(); i++) {
		if (command[i] == ' ') {
			if (i != pos) res.push_back(command.substring(pos, i - pos));
			pos = i + 1;
		}
	}
	return res;
}
template<class T>
void writeToFile(std::ofstream& fileOut, const T& a) {
	char* temp = (char*)&a;
	fileOut.write(temp, sizeof(a));
	// for (int i = 0; i < sizeof(a); i++) std::cout << (int)(*(temp + i)) << ' ';
	// std::cout << '\n';
}
void saveToFile(String filename, ld scale, ld cx, ld cy, ld timeSpeed, std::vector<planet> planets) {
	// std::cout << "WRITING*************************************************\n";
	std::ofstream fileOut((std::string)filename, std::ios::binary);
	writeToFile(fileOut, curIdCounter);
	writeToFile(fileOut, scale);
	writeToFile(fileOut, cx);
	writeToFile(fileOut, cy);
	writeToFile(fileOut, timeSpeed);
	int sz = planets.size();
	writeToFile(fileOut, sz);
	for (auto i : planets) {
		// std::cout << "\n\n\n";
		int szName = i.name.size();
		writeToFile(fileOut, szName);
		for (auto j : i.name) writeToFile(fileOut, j);
		writeToFile(fileOut, i.id);
		writeToFile(fileOut, i.m);
		writeToFile(fileOut, i.r);
		writeToFile(fileOut, i.selected);
		writeToFile(fileOut, i.vx);
		writeToFile(fileOut, i.vy);
		writeToFile(fileOut, i.x);
		writeToFile(fileOut, i.y);
	}
	fileOut.close();
}
template<class T>
void readFromFile(std::ifstream& fileIn, T& a) {
	char* temp = new char[sizeof(a)];
	fileIn.read(temp, sizeof(a));
	memcpy(&a, temp, sizeof(a));
	// for (int i = 0; i < sizeof(a); i++) std::cout << (int)(*(temp + i)) << ' ';
	// std::cout << '\n';
}
void loadFromFile(String filename, ld& scale, ld& cx, ld& cy, ld& timeSpeed, std::vector<planet>& planets) {
	// std::cout << "READING*************************************************\n";
	std::ifstream fileIn((std::string)filename, std::ios::binary);
	if (fileIn.is_open()) {
		readFromFile(fileIn, curIdCounter);
		readFromFile(fileIn, scale);
		readFromFile(fileIn, cx);
		readFromFile(fileIn, cy);
		readFromFile(fileIn, timeSpeed);
		int sz;
		readFromFile(fileIn, sz);
		planets.assign(sz, planet());
		for (auto& i : planets) {
			// std::cout << "\n\n\n";
			int szName;
			readFromFile(fileIn, szName);
			i.name.resize(szName);
			for (auto& j : i.name) readFromFile(fileIn, j);
			readFromFile(fileIn, i.id);
			readFromFile(fileIn, i.m);
			readFromFile(fileIn, i.r);
			readFromFile(fileIn, i.selected);
			readFromFile(fileIn, i.vx);
			readFromFile(fileIn, i.vy);
			readFromFile(fileIn, i.x);
			readFromFile(fileIn, i.y);
			if (fileIn.fail()) {
				std::cout << "WRONG!!!\n";
				throw(0);
			}
		}
		fileIn.close();
	}
}
void runSimulation(RenderWindow* window, gamestate* p) {
	Params params = { window, p };
	Thread calcThread(calculations, &params);
	window->setVerticalSyncEnabled(true);
	ld cx = 0, cy = 0, scale = 1e3;
	ld maxSpeed = 10;
	for (int i = 0; i < 0; i++) {
		ld angle = randnum(0, 1e6) / 1e6 * 2 * M_PI;
		ld len = randnum(0, scale * 1000);
		ld speedAngle = randnum(0, 1e6) / 1e6 * 2 * M_PI;
		ld speed = randnum(0, maxSpeed * 1000) / (ld)1000;
		ld r = randnum(1000, 2000);
		p->insertPlanet(planet(len * cos(angle), len * sin(angle), speed * cos(speedAngle), speed * sin(speedAngle), r, getVolume(r) * planet::DENSITY));
	}
	for (int i = 0; i < 0; i++) {
		ld angle = randnum(0, 1e6) / 1e6 * 2 * M_PI;
		ld len = randnum(0, scale * 1000);
		ld speedAngle = randnum(0, 1e6) / 1e6 * 2 * M_PI;
		ld speed = randnum(0, maxSpeed * 1000) / (ld)1000;
		p->insertPlanet(planet(len * cos(angle), len * sin(angle), speed * cos(speedAngle), speed * sin(speedAngle), 0, 0));
	}
	p->timeSpeed = 3600;

	scale = 1e9;
	p->insertPlanet(planet(0, 0, 0, 0, 695e6, 1.989e30, "Sun"));
	p->insertPlanet(planet(57.909e9, 0, 0, -47.87e3, 2.4e6, 3.302e23, "Mercury"));
	p->insertPlanet(planet(108.21e9, 0, 0, -35.02e3, 6.1e6, 4.869e24, "Venus"));
	p->insertPlanet(planet(152.10e9, 0, 0, -29.29e3, 6.371e6, 5.9724e24, "Earth"));
	p->insertPlanet(planet(152.10e9 + 363228e3, 0, 0, -29.29e3 - 1.082e3, 1737.4e3, 7.342e22, "Moon"));
	p->insertPlanet(planet(227.94e9, 0, 0, -24.13e3, 3.4e6, 6.419e23, "Mars"));
	p->insertPlanet(planet(778.41e9, 0, 0, -13.07e3, 71e6, 1.899e27, "Jupiter"));
	p->insertPlanet(planet(1429.4e9, 0, 0, -9.67e3, 60e6, 5.685e26, "Saturn"));
	p->insertPlanet(planet(2871.0e9, 0, 0, -6.84e3, 26e6, 8.685e25, "Uranus"));
	p->insertPlanet(planet(4498.3e9, 0, 0, -5.48e3, 25e6, 1.024e26, "Neptune"));
	p->timeSpeed = 10 * 86400;

	p->updateActions();
	psystem start__ = p->getPlanets();
	start__.updateCollided();
	p->setPlanets(start__);
	calcThread.launch();
	bool fullScreenPressed = false;
	Font font;
	font.loadFromFile("Resources\\font.ttf");
	Text updatesPerSecondText;
	updatesPerSecondText.setFont(font);
	updatesPerSecondText.setCharacterSize(10);

	bool locked = false;
	int lockedrealx, lockedrealy;
	int lastmousex = Mouse::getPosition(*window).x, lastmousey = Mouse::getPosition(*window).y;
	bool choosingSelected;

	int oldSelectedid = -1;

	int creationStep = -1;
	ld creationx, creationy, creationr, creationvx, creationvy;

	ld lastButtonUpdated = gettime();
	Uint8* lightPlanetsPixels = new Uint8[VideoMode::getFullscreenModes()[0].width * VideoMode::getFullscreenModes()[0].height * 4];
	for (int i = 0; i < VideoMode::getFullscreenModes()[0].width * VideoMode::getFullscreenModes()[0].height * 4; i++)lightPlanetsPixels[i] = 0;

	ld lastSelectedx, lastSelectedy;

	ld createDensity = planet::DENSITY;
	bool changeMassPressed = false;
	bool negativeMass = false;

	Chat chat;

	bool enterPressed = false;

	p->paused = true;
	bool pausePressed = false;

	bool drawLines = false;
	bool drawLinesPressed = false;

	while (window->isOpen()) {
		window->clear();
		p->lock();
		psystem psystem = p->getPlanets();
		p->unlock();
		std::vector<planet> planets = psystem.getPlanets();

		if (Keyboard::isKeyPressed(Keyboard::Enter) && chat.getTyping()) {
			if (!enterPressed && chat.getTyping()) {
				String curS = chat.getMessage();
				if (!curS.isEmpty()) {
					if (curS[0] == '/') {
						bool executed = false;
						String message;
						std::vector<String> parsed = parseCommand(curS);
						if (parsed[0] == (String)"/save") {
							if (parsed.size() == 2) {
								String filename = parsed[1];
								bool dotFound = false;
								for (auto i : filename) {
									if (i == '.') {
										dotFound = true;
										break;
									}
								}
								filename += String(".planets");
								saveToFile(filename, scale, cx, cy, p->timeSpeed, planets);
							}
							else {
								message = "Wrong argument quantity";
							}
						}
						if (parsed[0] == (String)"/load") {
							if (parsed.size() == 2) {
								String filename = parsed[1];
								bool dotFound = false;
								for (auto i : filename) {
									if (i == '.') {
										dotFound = true;
										break;
									}
								}
								filename += String(".planets");
								ld tempTimeSpeed;
								loadFromFile(filename, scale, cx, cy, tempTimeSpeed, planets);
								p->lock();
								p->setPlanets(planets);
								p->timeSpeed = tempTimeSpeed;
								p->unlock();
								for (auto i : planets) if (i.selected) {
									oldSelectedid = i.id;
									lastSelectedx = i.x;
									lastSelectedy = i.y;
								}
								p->paused = true;
							}
							else {
								message = "Wrong argument quantity";
							}
						}
					}
					else {
						chat.putMessage(curS);
					}
				}
				chat.send();
				chat.setTyping(false);
			}
			enterPressed = true;
		}
		else enterPressed = false;

		planet selected;
		bool isSelected = false;

		int curSelectedid = -1;
		for (auto i : planets) {
			if (i.id == oldSelectedid) {
				ld dx = i.x - lastSelectedx;
				ld dy = i.y - lastSelectedy;
				cx += dx;
				cy += dy;
				creationx += dx;
				creationy += dy;
			}
		}
		for (auto i : planets) {
			if (i.selected) {
				selected = i;
				isSelected = true;
				curSelectedid = i.id;
				lastSelectedx = i.x;
				lastSelectedy = i.y;
			}
		}
		oldSelectedid = curSelectedid;

		std::vector<std::pair<int, int>> lightPlanetsCoords;
		int lightCount = 0, heavyCount = 0;
		for (auto i : planets) {
			if (i.m != 0) {
				heavyCount++;
				i.draw(window, cx, cy, scale);
			}
			else {
				lightCount++;
				int drawx = getdrawx(i.x, cx, scale, window->getSize().x), drawy = getdrawy(i.y, cy, scale, window->getSize().y);
				if (0 <= drawx && drawx < window->getSize().x && 0 <= drawy && drawy < window->getSize().y) {
					lightPlanetsCoords.push_back(std::make_pair(drawx, drawy));
					Uint32 color = Color(172, 174, 216).toInteger();
					for (int i = 0; i < 4; i++) {
						lightPlanetsPixels[((drawx + drawy * window->getSize().x) << 2) + i] = ((color >> (24 - 8 * i)) & 255);
					}
				}
			}
			if (i.selected) {
				drawArrow(window, getdrawx(i.x, cx, scale, window->getSize().x), getdrawy(i.y, cy, scale, window->getSize().y), getdrawx(i.x + i.vx * p->timeSpeed, cx, scale, window->getSize().x), getdrawy(i.y + i.vy * p->timeSpeed, cy, scale, window->getSize().y), Color(255, 0, 0, 127));
				ld drawx = getdrawx(i.x, cx, scale, window->getSize().x);
				ld drawy = getdrawy(i.y, cy, scale, window->getSize().y);
				ld delta = i.r / scale + 5;
				drawLineSegment(window, drawx - delta, drawy - delta, drawx - delta, drawy + delta, Color(255, 255, 255, 255));
				drawLineSegment(window, drawx - delta, drawy - delta, drawx + delta, drawy - delta, Color(255, 255, 255, 255));
				drawLineSegment(window, drawx - delta, drawy + delta, drawx + delta, drawy + delta, Color(255, 255, 255, 255));
				drawLineSegment(window, drawx + delta, drawy - delta, drawx + delta, drawy + delta, Color(255, 255, 255, 255));
				std::vector<std::string>lines;
				if (i.name.size())lines.push_back(i.name);
				lines.push_back("m=" + to_string(i.m) + " kg");
				lines.push_back("r=" + formatDist(i.r));
				lines.push_back("v=" + formatDist(dist(0, 0, i.vx, i.vy)) + "/s");
				Text text(getName(lines), font, 10);
				text.setOrigin(getWidth(text) / 2, 0);
				text.setFillColor(Color(255, 255, 255, 255));
				text.setOutlineColor(Color(255, 255, 255, 255));
				text.setPosition((int)getdrawx(i.x, cx, scale, window->getSize().x), (int)getdrawy(i.y - i.r, cy, scale, window->getSize().y) + 7);
				window->draw(text);
			}
		}
		Image LightPlanetsImage;
		LightPlanetsImage.create(window->getSize().x, window->getSize().y, lightPlanetsPixels);
		for (auto i : lightPlanetsCoords) {
			int drawx = i.first, drawy = i.second;
			for (int i = 0; i < 4; i++) {
				lightPlanetsPixels[((drawx + drawy * window->getSize().x) << 2) + i] = 0;
			}
		}
		Texture lightPlanetsTexture;
		lightPlanetsTexture.loadFromImage(LightPlanetsImage);
		Sprite lightPlanetsSprite(lightPlanetsTexture);
		window->draw(lightPlanetsSprite);

		updatesPerSecondText.setString(to_string(p->getUpdatesPerSecond(), 1) + " UPS");
		updatesPerSecondText.setOrigin(0, getHeight(updatesPerSecondText) - 1);
		updatesPerSecondText.setPosition(0, window->getSize().y - 1 - 4);
		window->draw(updatesPerSecondText);

		ld buttondt = gettime() - lastButtonUpdated;
		lastButtonUpdated = gettime();
		if (window->hasFocus() && Keyboard::isKeyPressed(Keyboard::F11)) {
			if (!fullScreenPressed) {
				p->fullScreenMode = !p->fullScreenMode;
				if (!p->fullScreenMode) {
					window->create(VideoMode(960, 540), "Planets", sf::Style::Titlebar | sf::Style::Close);
				}
				else {
					window->create(VideoMode::getFullscreenModes()[0], "Planets", sf::Style::Fullscreen);
				}
			}
			fullScreenPressed = true;
		}
		else fullScreenPressed = false;
		if (window->hasFocus() && Keyboard::isKeyPressed(Keyboard::Escape)) {
			if (creationStep != -1) {
				creationStep = -1;
			}
			if (chat.getTyping()) {
				chat.setTyping(false);
			}
		}
		if (window->hasFocus() && !chat.getTyping()) {
			if (Keyboard::isKeyPressed(Keyboard::Comma)) {
				p->timeSpeed /= pow(3, buttondt);
			}
			if (Keyboard::isKeyPressed(Keyboard::Period)) {
				p->timeSpeed *= pow(3, buttondt);
			}
			if (Keyboard::isKeyPressed(Keyboard::Home)) {
				break;
			}
			if (Keyboard::isKeyPressed(Keyboard::Add) || Keyboard::isKeyPressed(Keyboard::Subtract)) {
				if (Keyboard::isKeyPressed(Keyboard::Add)) {
					createDensity *= pow(4, buttondt);
				}
				if (Keyboard::isKeyPressed(Keyboard::Subtract)) {
					createDensity /= pow(4, buttondt);
				}
			}
			if (Keyboard::isKeyPressed(Keyboard::M)) {
				if (!changeMassPressed) {
					negativeMass = !negativeMass;
				}
				changeMassPressed = true;
			}
			else changeMassPressed = false;
			if (Keyboard::isKeyPressed(Keyboard::P)) {
				if (!pausePressed) {
					p->paused = !p->paused;
				}
				pausePressed = true;
			}
			else pausePressed = false;
			if (Keyboard::isKeyPressed(Keyboard::L)) {
				if (!drawLinesPressed) {
					drawLines = !drawLines;
				}
				drawLinesPressed = true;
			}
			else drawLinesPressed = false;
		}

		if (creationStep == 0) {
			ld dx = getdrawx(creationx, cx, scale, window->getSize().x);
			ld dy = getdrawy(creationy, cy, scale, window->getSize().y);
			ld curr = dist(dx, dy, Mouse::getPosition(*window).x, Mouse::getPosition(*window).y);
			CircleShape tempPlanet;
			tempPlanet.setOrigin(curr, curr);
			tempPlanet.setRadius(curr);
			tempPlanet.setPosition(dx, dy);
			tempPlanet.setFillColor(Color(172, 174, 216, 63));
			window->draw(tempPlanet);
		}
		if (creationStep == 1) {
			ld drawx = getdrawx(creationx, cx, scale, window->getSize().x);
			ld drawy = getdrawy(creationy, cy, scale, window->getSize().y);
			ld r = creationr / scale;
			CircleShape tempPlanet;
			tempPlanet.setOrigin(r, r);
			tempPlanet.setRadius(r);
			tempPlanet.setPosition(drawx, drawy);
			tempPlanet.setFillColor(Color(172, 174, 216, 63));
			window->draw(tempPlanet);
			drawArrow(window, drawx, drawy, Mouse::getPosition(*window).x, Mouse::getPosition(*window).y, Color::Red);
		}
		if (creationStep != -1) {
			ld drawx = getdrawx(creationx, cx, scale, window->getSize().x);
			ld drawy = getdrawy(creationy, cy, scale, window->getSize().y);
			ld r = ((creationStep == 0) ? (dist(drawx, drawy, Mouse::getPosition(*window).x, Mouse::getPosition(*window).y) * scale) : creationr);
			std::vector<std::string>lines;
			lines.push_back("m=" + (negativeMass ? "-" : std::string()) + to_string(getVolume(r) * createDensity) + " kg");
			lines.push_back("r=" + formatDist(r));
			ld vx = creationx - getrealx(Mouse::getPosition(*window).x, cx, scale, window->getSize().x);
			ld vy = creationy - getrealy(Mouse::getPosition(*window).y, cy, scale, window->getSize().y);
			if (isSelected) {
				vx -= selected.vx;
				vy -= selected.vy;
			}
			vx /= p->timeSpeed;
			vy /= p->timeSpeed;
			ld v = ((creationStep == 0) ? 0 : dist(0, 0, vx, vy));
			lines.push_back("v=" + formatDist(v) + "/s");
			Text text(getName(lines), font, 10);
			text.setOrigin(getWidth(text) / 2, 0);
			text.setFillColor(Color(255, 255, 255, 255));
			text.setOutlineColor(Color(255, 255, 255, 255));
			text.setPosition((int)getdrawx(creationx, cx, scale, window->getSize().x), (int)getdrawy(creationy - r, cy, scale, window->getSize().y) + 7);
			window->draw(text);
		}
		Text data1;
		data1.setCharacterSize(10);
		data1.setFont(font);
		std::string data1string;
		data1string += "Time speed:\n" + formatTime(p->timeSpeed) + "/s\n";
		data1string += "Scale: " + formatDist(scale) + "/pixel\n";
		data1string += "Objects count:\n" + std::to_string(planets.size()) + " (" + std::to_string(heavyCount) + "+" + std::to_string(lightCount) + ")\n";
		data1string += "Create density: " + (negativeMass ? "-" : std::string()) + to_string(createDensity, 0) + " kg/m^3\n";
		data1.setString(data1string);
		data1.setOrigin(getWidth(data1) - 1, 0);
		data1.setPosition(window->getSize().x - 1, 0);
		data1.setFillColor(Color::White);
		window->draw(data1);
		if (p->paused) {
			Text data2;
			data2.setCharacterSize(10);
			data2.setFont(font);
			data2.setString("Pause");
			window->draw(data2);
		}
		chat.draw(window, font);
		window->display();
		if (locked) {
			int curx = Mouse::getPosition(*window).x;
			int cury = Mouse::getPosition(*window).y;
			if (dist(curx, cury, lockedrealx, lockedrealy) > 10) {
				choosingSelected = false;
			}
		}
		Event event;
		while (window->pollEvent(event)) {
			static bool tPressed = false;
			if (event.type == Event::Closed) {
				window->close();
			}
			else if (event.type == Event::TextEntered) {
				Uint32 c = event.text.unicode;
				if (chat.getTyping()) {
					if (!tPressed) {
						chat.putChar(c);
					}
					else {
						tPressed = false;
					}
				}
			}
			else if (event.type == Event::MouseWheelMoved) {
				if (window->hasFocus()) {
					if (!chat.getTyping()) {
						int cur = event.mouseWheel.delta;
						ld mScale = 1;
						for (int i = 0; i < abs(cur); i++) {
							mScale *= (ld)1.1;
						}
						ld mousex = Mouse::getPosition(*window).x, mousey = Mouse::getPosition(*window).y;
						ld tx = cx + (mousex - window->getSize().x / 2) * scale, ty = cy + (window->getSize().y / 2 - mousey) * scale;
						ld vx = -(mousex - window->getSize().x / 2), vy = -(window->getSize().y / 2 - mousey);
						if (cur < 0) {
							scale *= mScale;
						}
						else {
							scale /= mScale;
						}
						cx = tx + vx * scale;
						cy = ty + vy * scale;
					}
					else {
						int dpos = event.mouseWheel.delta;
						if (chat.getTyping()) {
							chat.scroll(dpos);
						}
					}
				}
			}
			else if (event.type == Event::KeyPressed) {
				if (event.key.code == Keyboard::Up) {
					if (chat.getTyping() && window->hasFocus()) {
						chat.goUp();
					}
				}
				if (event.key.code == Keyboard::Down) {
					if (chat.getTyping() && window->hasFocus()) {
						chat.goDown();
					}
				}
				if (event.key.code == Keyboard::Left) {
					if (chat.getTyping()) {
						if (!Keyboard::isKeyPressed(Keyboard::LControl) && !Keyboard::isKeyPressed(Keyboard::RControl)) {
							chat.moveCursor(-1);
						}
						else chat.moveCursorCtrl(-1);
					}
				}
				if (event.key.code == Keyboard::Right) {
					if (chat.getTyping()) {
						if (!Keyboard::isKeyPressed(Keyboard::LControl) && !Keyboard::isKeyPressed(Keyboard::RControl)) {
							chat.moveCursor(1);
						}
						else chat.moveCursorCtrl(1);
					}
				}
				if (event.key.code == Keyboard::Delete) {
					if (chat.getTyping()) {
						chat.deleteSymbol();
					}
				}
				if (event.key.code == Keyboard::T) {
					if (!chat.getTyping()) {
						tPressed = true;
						chat.setTyping(true);
					}
				}
				if (event.key.code == Keyboard::Slash) {
					if (!chat.getTyping()) {
						chat.setTyping(true);
					}
				}
			}
			else if (event.type == Event::MouseButtonPressed) {
				if (window->hasFocus()) {
					if (event.mouseButton.button == Mouse::Left && !Keyboard::isKeyPressed(Keyboard::LAlt)) {
						locked = true;
						lockedrealx = Mouse::getPosition(*window).x;
						lockedrealy = Mouse::getPosition(*window).y;
						choosingSelected = true;
						creationStep = -1;
					}
					if (Keyboard::isKeyPressed(Keyboard::LAlt) && event.mouseButton.button == Mouse::Left || event.mouseButton.button == Mouse::Middle) {
						ld curx = getrealx(Mouse::getPosition(*window).x, cx, scale, window->getSize().x);
						ld cury = getrealy(Mouse::getPosition(*window).y, cy, scale, window->getSize().y);
						if (creationStep == -1) {
							creationx = curx;
							creationy = cury;
							creationStep = 0;
						}
						else if (creationStep == 0) {
							creationr = dist(curx, cury, creationx, creationy);
							creationStep = 1;
						}
						else if (creationStep == 1) {
							creationvx = (curx - creationx) / p->timeSpeed;
							creationvy = (cury - creationy) / p->timeSpeed;
							if (isSelected) {
								creationvx += selected.vx;
								creationvy += selected.vy;
							}
							p->insertPlanet(planet(creationx, creationy, creationvx, creationvy, creationr, getVolume(creationr) * createDensity * (negativeMass ? -1 : 1)));
							creationStep = -1;
						}
					}
					if (event.mouseButton.button == Mouse::Right) {
						ld curx = getrealx(Mouse::getPosition(*window).x, cx, scale, window->getSize().x);
						ld cury = getrealy(Mouse::getPosition(*window).y, cy, scale, window->getSize().y);
						ld maxdist = scale * 20;
						p->lock();
						p->deletePlanets(curx, cury, maxdist);
						p->unlock();
					}
				}
			}
			else if (event.type == Event::MouseButtonReleased) {
				if (window->hasFocus()) {
					if (event.mouseButton.button == Mouse::Left && !Keyboard::isKeyPressed(Keyboard::LAlt)) {
						if (locked) {
							locked = false;
							if (choosingSelected && !Keyboard::isKeyPressed(Keyboard::LAlt)) {
								ld mindist;
								int curx = Mouse::getPosition(*window).x;
								int cury = Mouse::getPosition(*window).y;
								int selected = -1;
								for (int i = 0; i < planets.size(); i++) {
									if (planets[i].selected) {
										oldSelectedid = planets[i].id;
									}
									ld drawx = getdrawx(planets[i].x, cx, scale, window->getSize().x);
									ld drawy = getdrawy(planets[i].y, cy, scale, window->getSize().y);
									ld d = dist(curx, cury, drawx, drawy) - planets[i].r / scale;
									if (d < 0) {
										selected = i;
										mindist = d;
									}
									else if (d < 20 && (selected == -1 || d < mindist)) {
										selected = i;
										mindist = d;
									}
								}
								p->lock();
								p->select(((selected == -1) ? -1 : planets[selected].id));
								p->unlock();
							}
						}
					}
				}
			}
			else if (event.type == Event::MouseMoved) {
				if (window->hasFocus()) {
					if (locked) {
						int curx = Mouse::getPosition(*window).x;
						int cury = Mouse::getPosition(*window).y;
						cx -= (curx - lastmousex) * scale;
						cy += (cury - lastmousey) * scale;
					}
				}
			}
		}
		lastmousex = Mouse::getPosition(*window).x;
		lastmousey = Mouse::getPosition(*window).y;
	}
	p->close();
	calcThread.wait();
}
int main() {
	RenderWindow* window = new RenderWindow();
	gamestate* p = new gamestate();
	p->fullScreenMode = false;
	if (!p->fullScreenMode) {
		window->create(VideoMode(960, 540), "Planets", sf::Style::Titlebar | sf::Style::Close);
	}
	else {
		window->create(VideoMode::getFullscreenModes()[0], "Planets", sf::Style::Fullscreen);
	}
	window->setVerticalSyncEnabled(true);
	bool fullScreenPressed = false;
	Font font;
	font.loadFromFile("Resources\\font.ttf");
	while (window->isOpen()) {
		window->clear();
		Text text;
		text.setPosition(0, 0);
		text.setFont(font);
		text.setString("Press enter");
		text.setCharacterSize(30);
		window->draw(text);
		window->display();
		if (window->hasFocus() && Keyboard::isKeyPressed(Keyboard::F11)) {
			if (!fullScreenPressed) {
				p->fullScreenMode = !p->fullScreenMode;
				if (!p->fullScreenMode) {
					window->create(VideoMode(960, 540), "Planets", sf::Style::Titlebar | sf::Style::Close);
				}
				else {
					window->create(VideoMode::getFullscreenModes()[0], "Planets", sf::Style::Fullscreen);
				}
			}
			fullScreenPressed = true;
		}
		else fullScreenPressed = false;
		Event event;
		while (window->pollEvent(event)) {
			if (event.type == Event::Closed) {
				window->close();
			}
			else if (event.type == Event::TextEntered) {
				if (event.text.unicode == 13) {
					p->clear();
					runSimulation(window, p);
				}
			}
		}
	}
	return 0;
}